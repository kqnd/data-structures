package dsa

import (
	"fmt"
	"strings"

	"github.com/kqnd/dsa/utils"
)

type Book struct {
	ID int
	Title string
}

type LeafTreeNode struct {
	Key int
	Left, Right *LeafTreeNode
	Leaf *Book
}

type LeafTree struct {
	Root *LeafTreeNode
}

var rootKey = utils.Generate(200, 1000)

// QUICK USAGE
// func main() {
	
// 	book1 := dsa.CreateBook("The Great Gatsby")
// 	book2 := dsa.CreateBook("1984")

// 	lt := dsa.CreateLeafTree()
// 	lt.Add(nil)
// 	lt.Add(nil)
// 	lt.Add(nil)
// 	lt.Add(nil)
// 	bookOneDB := lt.Add(book1)
// 	bookTwoDB := lt.Add(book2)
// 	lt.Show()

// 	bookByKey := lt.Find(bookOneDB.Key)
// 	bookByID := lt.FindByBookID(bookTwoDB.Leaf.ID)

// 	if bookByKey != nil {
// 		fmt.Printf("FIND_KEY: [%d] Book: %s\n", bookOneDB.Key, bookByKey.Leaf.Title)
// 	}

// 	if bookByID != nil {
// 		fmt.Printf("FIND_BY_ID: [%d] Book: %s\n", bookTwoDB.Key, bookByID.Leaf.Title)
// 	}

// }

func CreateLeafTree() *LeafTree {
	return &LeafTree{
		Root: &LeafTreeNode{
			Key: rootKey,
			Left: nil,
			Right: nil,
			Leaf: nil,
		},
	}
}

func CreateBook(title string) *Book {
	bookID := utils.Generate(1000, 9999)
	fmt.Printf("Creating book: %s [#%d]\n", title, bookID)
	return &Book{
		ID: bookID,
		Title: title,
	}
}

func (t *LeafTree) Add(book *Book) *LeafTreeNode {
	key := utils.Generate(1, 2000)
	node := addLeafRecursively(t.Root, key, book)
	t.Root = node
	return t.Find(key)
}

func addLeafRecursively(node *LeafTreeNode, key int, book *Book) *LeafTreeNode {
	if node == nil {
		newNode := LeafTreeNode{
			Key: key,
			Leaf: book,
		}
		if book != nil {
			fmt.Printf("Added book: %s [#%d] with key %d\n", book.Title, book.ID, key)
		}
		return &newNode
	}

	if key < node.Key {
		node.Left = addLeafRecursively(node.Left, key, book)
	} else {
		node.Right = addLeafRecursively(node.Right, key, book)
	}

	return node
}

// 1 

func (lt *LeafTree) Find(key int) *LeafTreeNode {
	return findRecursively(lt.Root, key)
}

func (lt *LeafTree) FindByBookID(id int) *LeafTreeNode {
	return findByBookID(lt.Root, id)
}

func findByBookID(node *LeafTreeNode, id int) *LeafTreeNode {
	if node == nil {
		return node
	}

	if node.Leaf != nil && node.Leaf.ID == id {
		return node
	}

	if left := findByBookID(node.Left, id); left != nil {
		return left
	}

	return findByBookID(node.Right, id)
}

func findRecursively(node *LeafTreeNode, key int) *LeafTreeNode {
	if node == nil || node.Key == key {
		return node
	}
	
	if key < node.Key {
		return findRecursively(node.Left, key)
	} else {
		return findRecursively(node.Right, key)
	}
}

func printLeafNode(node *LeafTreeNode, depth int) {
	if node == nil {
		return
	}

	leafInfo := ""
	if node.Leaf != nil {
		leafInfo = fmt.Sprintf(" [%s #%d]", node.Leaf.Title, node.Leaf.ID)
	}

	printLeafNode(node.Right, depth+1)
	fmt.Printf("%s%d%s\n", strings.Repeat("    ", depth), node.Key, leafInfo)
	printLeafNode(node.Left, depth+1)
}


func (lt *LeafTree) Show() {
	if lt.Root == nil {
		fmt.Println("Tree is empty")
		return
	}
	
	fmt.Println("========= LEAF TREE =========")
	printLeafNode(lt.Root, 0)
	fmt.Println("========= END LEAF TREE =========")
}
